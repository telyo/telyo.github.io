<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[git常用命令]]></title>
      <url>%2F2016%2F10%2F29%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[gitignore文件.gitignore顾名思义就是告诉git需要忽略的文件，这是一个很重要并且很实用的文件。一般我们写完代码后会执行编译、调试等操作，这期间会产生很多中间文件和可执行文件，这些都不是代码文件，是不需要git来管理的。我们在git status的时候会看到很多这样的文件，如果用git add -A来添加的话会把他们都加进去，而手动一个个添加的话也太麻烦了。这时我们就需要.gitignore了。 Git命令查看、添加、提交、删除、找回，重置修改文件1234567891011121314151617181920212223242526272829git help &lt;command&gt; # 显示command的helpgit show # 显示某次提交的内容 git show $idgit co -- &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt; git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am "some comments"git ci --amend # 修改最后一次提交记录git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象git revert HEAD # 恢复最后一次提交的状态 查看文件diff1234567891011git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diffgit diff &lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较git diff --staged # 比较暂存区和版本库差异git diff --cached # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息 查看提交记录1234567git log git log &lt;file&gt; # 查看该文件每次提交记录git log -p &lt;file&gt; # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat #查看提交统计信息 tigMac上可以使用tig代替diff和log，brew install tig Git 本地分支管理查看、切换、创建和删除分支1234567891011121314151617181920212223git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br --merged # 查看已经被合并到当前分支的分支git br --no-merged # 查看尚未被合并到当前分支的分支git co &lt;branch&gt; # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt; # 删除某个分支git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase12345git merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用)12345git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply --check ../sync.patch #测试补丁能否成功 Git暂存管理123456789101112131415161718192021git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上 git push # push所有分支123456789git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 Git远程仓库管理1234567git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库 创建远程仓库12345678910111213git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库123git branch --set-upstream master origin/mastergit branch --set-upstream develop origin/develop 转载地址 延伸阅读 同时可以看progit.pdf比较全的git资料。。。。 over…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android无限消息推送]]></title>
      <url>%2F2016%2F10%2F29%2Fandroid%E6%97%A0%E9%99%90%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%2F</url>
      <content type="text"><![CDATA[功能说明android开发通常会遇到消息推送的需求，但是今天的这个消息推送有点特殊，因为它的目的主要不是推送消息，而是在某种特定需求下比如说：用户需要某一项服务需要一直打开APP，这时就定期的向系统发送消息表示服务正在运行，服务就不那么容易被系统杀死，等等一些特殊的情况下用这个方法保持程序一直运行。所以请慎用！！！ 好了不说了直接上代码： 新建一个项目，创建一个NotificationService类继承service12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class NotificationServise extends Service &#123; private Timer timer; private final int notification_ID = 0; private NotificationManager manager; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; //获取全局变量manger用于管理消息推送 manager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE); //获取参数 isStent 判断是否推送 Bundle bundle = intent.getExtras(); Boolean isSent = bundle.getBoolean("isSend")； if (isSent == true) &#123; if (timer == null) &#123; timer = new Timer(); timer.scheduleAtFixedRate(new RefreshTask(), 0, 5000); &#125; &#125; else &#123; manager.cancel(notification_ID); stopService(intent); &#125; return super.onStartCommand(intent, flags, startId); &#125; //内部类执行循环过程 class RefreshTask extends TimerTask &#123; @Override public void run() &#123; sendNotification(); &#125; &#125; //发送消息 private void sendNotification()&#123; Intent intent = new Intent(this,MainActivity.class); PendingIntent pentent = PendingIntent.getActivity(this,0,intent,0); Notification.Builder builder = new Notification.Builder(this); builder.setSmallIcon(R.mipmap.icon); builder.setTicker("S2M"); builder.setContentText(getResources().getString(R.string.S2M_work)); builder.setWhen(System.currentTimeMillis()); builder.setContentIntent(pentent); Notification notification =builder.build(); manager.notify(notification_ID,notification); &#125;&#125; 然后在MainAvtivity中启动serveice即可 123456Intent nIntent = new Intent(this, NotificationServise.class); Bundle nBundle = new Bundle(); //这里可以根据需求设置isStent的值， nBundle.putBoolean("isSend",isSend); nIntent.putExtras(nBundle); startService(nIntent); 好了到此结束~~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android ListView进阶写法]]></title>
      <url>%2F2016%2F10%2F26%2FSuperAdapter%2F</url>
      <content type="text"><![CDATA[android一劳永逸的封装 强大的封装在了解到android开发的一些语言规则，然后对封装这个概念有一定理解后，之后的学习之路也感觉变得轻松一点点啦，android开发感觉就是对类、方法、参数的使用达到预期的效果，封装就会使我们的开发变得更加效率！在开发自己的软件的时候，对一个类，方法的自定义并且封装是非常常见的事情，我觉得万能的ListView就是一个很强大的列子，把原来封装好的类再进行优化封装，在重复用到适配listView的时候直接复制粘贴，传递自己的参数就是这么简单！这就是传说中的一劳永逸吧！ 进入正题 传统的listView适配方法为了对比还是得先熟悉一下传统方式的ListView适配的方法 新建一个demo ：superListViewAdapter activity_main.xml如下 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="superadapter.telyo.superlistadapter.MainActivity"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Super Adapter" android:textSize="30dp"/&gt; &lt;ListView android:layout_width="match_parent" android:layout_height="match_parent" android:id="@+id/list"&gt; &lt;/ListView&gt;&lt;/LinearLayout&gt; 写一个item的xlm样式如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="50dp" android:layout_gravity="center" android:gravity="center" android:orientation="horizontal"&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginLeft="20dp" android:id="@+id/icon" android:src="@mipmap/ic_launcher"/&gt; &lt;LinearLayout android:layout_width="0dp" android:layout_weight="1" android:layout_height="match_parent" android:gravity="center_vertical" android:orientation="vertical"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/title" android:text="Title"/&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/content" android:text="Content"/&gt; &lt;/LinearLayout&gt; &lt;CheckBox android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/checkbox" android:layout_marginRight="20dp"/&gt;&lt;/LinearLayout&gt; 为item样式写一个容器类ContactItem.java 代码如下： 1234567891011121314151617181920212223public class ContactItem &#123; private String title; private String content; private ImageView icon; public String getContent() &#123; return content; &#125; public ImageView getIcon() &#123; return icon; &#125; public String getTitle() &#123; return title; &#125; public void setContext(String context) &#123; this.content = context; &#125; public void setTitle(String title) &#123; this.title = title; &#125;&#125; MainActivit.java 代码如下 12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity &#123; private MyAdapter myAdapter; private ListView mlistView; private List&lt;ContactItem&gt; mContactItem = new ArrayList&lt;ContactItem&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initData(); initView(); &#125; private void initView() &#123; mlistView = (ListView) findViewById(R.id.list); mlistView.setAdapter(myAdapter); &#125; private void initData()&#123; if (mContactItem.size() ==0)&#123; for( int i = 0;i &lt; 12; i++)&#123; ContactItem item = new ContactItem(); item.setTitle("我是标题" + i); item.setContext("我是内容" + i); mContactItem.add(item); //System.out.println(mContactItem.get(i).getTitle()); &#125; &#125; myAdapter = new MyAdapter(this,mContactItem); &#125;&#125; 再接下来就是写Adapter了 创建MyAdapter 继承BaseAdapter在MyAdapter()方法中定义需要传入的两个参数：上下文和item的内容容器。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class MyAdapter extends BaseAdapter &#123; private LayoutInflater mInflater ; private List&lt;ContactItem&gt; mData; public MyAdapter(Context context, List&lt;ContactItem&gt; datas) &#123; mInflater = LayoutInflater.from(context); mData = datas; &#125; @Override public int getCount() &#123; return mData.size(); &#125; @Override public Object getItem(int i) &#123; return mData.get(i); &#125; @Override public long getItemId(int i) &#123; return i; &#125; /** * * @param i item的位置 * @param view item 的View 用于显示item的样式，里面所有的控件 * 文字啊、图片啊、按钮什么的都要用到 view.getviewById（）的方法找到 * @param viewGroup 这里我理解我整个ListView 的view * @return */ @Override public View getView(final int i, View view, ViewGroup viewGroup) &#123; //初始化holder ViewHolder holder; if(view == null)&#123; view = mInflater.inflate(R.layout.list_item,viewGroup,false); holder = new ViewHolder(); holder.title = (TextView) view.findViewById(R.id.title); holder.content = (TextView) view.findViewById(R.id.content); holder.icon = (ImageView) view.findViewById(R.id.icon); holder.checkBox = (CheckBox) view.findViewById(R.id.checkbox); view.setTag(holder); &#125;else &#123; holder = (ViewHolder) view.getTag(); &#125; // ContactItem item = mData.get(i); holder.title.setText(item.getTitle()); holder.content.setText(item.getContent()); holder.icon.setImageResource(R.mipmap.ic_launcher); //System.out.println(mData.get(i).getTitle() + i); return view; &#125;//因为传统写法每一个adapter对应一个listView，说以item的样式和内容基本上是会改变的，//所以ViewHolder类就放在MyAdapter类里面了 private class ViewHolder&#123; public TextView title; public TextView content; public ImageView icon; public CheckBox checkBox; &#125;&#125; 好了传统的方法就是这样了，运行一下看看结果： 封装ViewHolderViewHolder优化分析： 由于—&gt;&gt;&gt; 1、convertView的view.setTag（holder）;2、ViewHolder：对convertView里各种控件的引用 所以—&gt;&gt;&gt; ViewHolder类作为一个view的容器给convertView提供控件，使用比Map更高效的SparseArray作为view的容器 在ViewHolder里提供一个getView（int id）的方法得到相应的view进行操作 12345public View getView(final int i, View view, ViewGroup viewGroup) &#123;ViewHolder holder = ...;TextView tv = holder.getView(view id);tv.setText(...);&#125; 开始简化了： 1、将MyAdapter 里初始化ViewHolder的代码封装，新建一个包utils，里面新建一个ViewHolder类，holder需要引用到一些控件，这些控件需要convertView的findViewByID()方法找到，所以需要在ViewHolder（）方法里传入convertView参数，convertView需要他的parent inflate引入所以也传入parent参数，position将来点击事件也会用到这里先传入。具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ViewHolder &#123; private SparseArray&lt;View&gt; mViews; private int mPosition; private View mConvertView; //这里是用于初始化ViewHolder的两个方法 public ViewHolder(Context context,int positon,ViewGroup perent,int layoutId) &#123; this.mPosition = positon; this.mViews = new SparseArray&lt;View&gt;(); mConvertView = LayoutInflater.from(context).inflate(layoutId,perent,false); mConvertView.setTag(this); &#125; public static ViewHolder get(Context context,int positon,ViewGroup perent,int layoutId,View convertView)&#123; if (convertView == null)&#123; return new ViewHolder(context,positon,perent,layoutId); &#125;else &#123; return (ViewHolder)convertView.getTag(); &#125; &#125; /* 通过viewId获取控件 建一个类（泛型T）继承View 里面定义一个getView方法，返回一个view */ public &lt;T extends View&gt; T getView(int viewId)&#123; View view = mViews.get(viewId); if (view == null)&#123; view =mConvertView.findViewById(viewId); mViews.put(viewId,view); &#125; return (T) view; &#125; //对外公布方法获取convertView， public View getmConvertView() &#123; return mConvertView; &#125; //现在虽然用不到position 以后设置item点击的时候总会用到先写在这里 public int getmPosition() &#123; return mPosition; &#125;&#125; 然后简化Adapter 在utils包里新建一个MyAdapterWithCommonViewHolder类 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738public class CommonAdapter extends BaseAdapter &#123; // private LayoutInflater mInflater ; private List&lt;ContactItem&gt; mData; private Context mContent; public CommonAdapter(Context context, List&lt;ContactItem&gt; datas) &#123; //mInflater = LayoutInflater.from(context); mData = datas; this.mContent = context; &#125; @Override public int getCount() &#123; return mData.size(); &#125; @Override public Object getItem(int i) &#123; return mData.get(i); &#125; @Override public long getItemId(int i) &#123; return i; &#125; @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; ViewHolder holder = ViewHolder.get(mContent,i,viewGroup,R.layout.list_item,view); ContactItem item = mData.get(i); ((TextView)holder.getView(R.id.title)).setText(item.getTitle()); ((TextView)holder.getView(R.id.content)).setText(item.getContent()); ((ImageView)holder.getView(R.id.icon)).setImageResource(R.mipmap.ic_launcher); //System.out.println(mData.get(i).getTitle() + i); return holder.getmConvertView(); &#125; 这时候比较一下初始化holder的代码就没有了，注意最后一行应该是return holder.getmConvertView(); 修改MainActivity： 12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity &#123; private ListView mlistView; private CommonAdapter mCommonAdapter; private List&lt;ContactItem&gt; mContactItem = new ArrayList&lt;ContactItem&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initData(); initView(); &#125; private void initView() &#123; mlistView = (ListView) findViewById(R.id.list); mlistView.setAdapter(mCommonAdapter); &#125; private void initData()&#123; if (mContactItem.size() ==0)&#123; for( int i = 0;i &lt; 12; i++)&#123; ContactItem item = new ContactItem(); item.setTitle("我是标题" + i); item.setContext("我是内容" + i); mContactItem.add(item); &#125; &#125; mCommonAdapter = new CommonAdapter(this,mContactItem); &#125;&#125; 封装Adapter 在utils包里新建一个CommonAdapterFinal类 代码如下： 1234567891011121314151617181920212223242526272829public abstract class CommonAdapterFinal&lt;T&gt; extends BaseAdapter &#123; protected Context mContext; protected List&lt;T&gt; mDatas; protected LayoutInflater mInflater; public CommonAdapterFinal(Context context, List&lt;T&gt; datas) &#123; this .mContext = context; mInflater = LayoutInflater.from(context); this.mDatas = datas; &#125; @Override public int getCount() &#123; return mDatas.size(); &#125; @Override public Object getItem(int i) &#123; return mDatas.get(i); &#125; @Override public long getItemId(int i) &#123; return i; &#125; @Override public abstract View getView(int i, View view, ViewGroup viewGroup);&#125; 这个类封装好了主要是用来继承的，那么原来的CommonAdapter可以写的很简单了，让CommonAdapter继承CommonAdapterFinal代码如下： 123456789101112131415161718public class CommonAdapter extends CommonAdapterFinal&lt;ContactItem&gt; &#123; public CommonAdapter(Context context, List&lt;ContactItem&gt; datas) &#123; super(context,datas); &#125; @Override public View getView(int i, View view, ViewGroup viewGroup) &#123; ViewHolder holder = ViewHolder.get(mContext,i,viewGroup,R.layout.list_item,view); ContactItem item = mDatas.get(i); ((TextView)holder.getView(R.id.title)).setText(item.getTitle()); ((TextView)holder.getView(R.id.content)).setText(item.getContent()); ((ImageView)holder.getView(R.id.icon)).setImageResource(R.mipmap.ic_launcher); return holder.getmConvertView(); &#125;&#125; MainActivity代码不变 所以有了CommonAdapterFall类和封装好的ViewHolder类以后，遇到再多listView只需要拷贝这两个类，写一个adapter继承CommonAdapterFall即可！接下来在对这两个类进行优化，可以做到适配一个listView只需要短短几行代码就可以实现！ 进阶优化 还是对adapter进行优化，原则是：有能用方法传递参数给子类的方式，就绝不在子类写方法获取，能在父类返回的参数值也不会再子类中去返回，子类继承后就没事了！CommonAdapterFall修改如下： 12345678910111213141516171819202122232425262728293031323334353637public abstract class CommonAdapterFinal&lt;T&gt; extends BaseAdapter &#123; protected Context mContext; protected List&lt;T&gt; mDatas; protected LayoutInflater mInflater; public CommonAdapterFinal(Context context, List&lt;T&gt; datas) &#123; this .mContext = context; mInflater = LayoutInflater.from(context); this.mDatas = datas; &#125; @Override public int getCount() &#123; return mDatas.size(); &#125; @Override public T getItem(int i) &#123; return mDatas.get(i); &#125; @Override public long getItemId(int i) &#123; return i; &#125; @Override public View getView(int i, View view, ViewGroup viewGroup)&#123; ViewHolder holder = ViewHolder.get(mContext,i,viewGroup, R.layout.list_item,view); convert(holder,getItem(i)); return holder.getmConvertView(); &#125; //抽象一个方法传递参数给子类实现 public abstract void convert(ViewHolder holder,T t);&#125; 然后每次用到的adapter简化如下： 1234567891011121314public class CommonAdapter extends CommonAdapterFinal&lt;ContactItem&gt; &#123; public CommonAdapter(Context context, List&lt;ContactItem&gt; datas) &#123; super(context,datas); &#125; @Override public void convert(ViewHolder holder, ContactItem contactItem) &#123; ((TextView)holder.getView(R.id.title)).setText(contactItem.getTitle()); ((TextView)holder.getView(R.id.content)).setText(contactItem.getContent()); ((ImageView)holder.getView(R.id.icon)).setImageResource(R.mipmap.ic_launcher); &#125;&#125; 是不是又短了一点！ 到此为止了么其实没有！ 继续简化吧！！！ 看最终代码： ViewHolder类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class ViewHolder &#123; private SparseArray&lt;View&gt; mViews; private int mPosition; private View mConvertView; //这里是用于初始化ViewHolder的两个方法 public ViewHolder(Context context,int positon,ViewGroup perent,int layoutId) &#123; this.mPosition = positon; this.mViews = new SparseArray&lt;View&gt;(); mConvertView = LayoutInflater.from(context).inflate(layoutId,perent,false); mConvertView.setTag(this); &#125; public static ViewHolder get(Context context,int positon,ViewGroup perent,int layoutId,View convertView)&#123; if (convertView == null)&#123; return new ViewHolder(context,positon,perent,layoutId); &#125;else &#123; return (ViewHolder)convertView.getTag(); &#125; &#125; /* 通过viewId获取控件 建一个类（泛型T）继承View 里面定义一个getView方法，返回一个view */ public &lt;T extends View&gt; T getView(int viewId)&#123; View view = mViews.get(viewId); if (view == null)&#123; view =mConvertView.findViewById(viewId); mViews.put(viewId,view); &#125; return (T) view; &#125; //对外公布方法获取convertView， public View getmConvertView() &#123; return mConvertView; &#125; //现在虽然用不到position 以后设置item点击的时候总会用到先写在这里 public int getmPosition() &#123; return mPosition; &#125; //直接调用代码设置listView 每个item里的控件的相关值，以后缺什么就直接在这里加 public ViewHolder setText(int viewId,String text)&#123; TextView tv = getView(viewId); tv.setText(text); return this; &#125; public ViewHolder setImageResource(int viewId,int imgId)&#123; ImageView iv = getView(viewId); iv.setImageResource(imgId); return this; &#125;&#125; CommonAdapterFinal类 1234567891011121314151617181920212223242526272829303132333435363738public abstract class CommonAdapterFinal&lt;T&gt; extends BaseAdapter &#123; protected Context mContext; protected List&lt;T&gt; mDatas; protected LayoutInflater mInflater; protected int mLayoutId; public CommonAdapterFinal(Context context, List&lt;T&gt; datas,int layoutId) &#123; this .mContext = context; mInflater = LayoutInflater.from(context); this.mDatas = datas; this.mLayoutId = layoutId; &#125; @Override public int getCount() &#123; return mDatas.size(); &#125; @Override public T getItem(int i) &#123; return mDatas.get(i); &#125; @Override public long getItemId(int i) &#123; return i; &#125; @Override public View getView(int i, View view, ViewGroup viewGroup)&#123; ViewHolder holder = ViewHolder.get(mContext,i,viewGroup,mLayoutId,view); convert(holder,getItem(i)); return holder.getmConvertView(); &#125; //抽象一个方法传递参数给子类实现 public abstract void convert(ViewHolder holder,T t);&#125; 以后需要写listView直接复制这两个类就行了 自己的容器：ContactItem 1234567891011121314151617181920212223public class ContactItem &#123; private String title; private String content; private ImageView icon; public String getContent() &#123; return content; &#125; public ImageView getIcon() &#123; return icon; &#125; public String getTitle() &#123; return title; &#125; public void setContext(String context) &#123; this.content = context; &#125; public void setTitle(String title) &#123; this.title = title; &#125;&#125; 然后就是MainActivity: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MainActivity extends AppCompatActivity &#123; private ListView mlistView; private CommonAdapter mCommonAdapter; private List&lt;ContactItem&gt; mContactItem = new ArrayList&lt;ContactItem&gt;(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initData(); initView(); &#125; private void initView() &#123; mlistView = (ListView) findViewById(R.id.list); mlistView.setAdapter(mCommonAdapter); mlistView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int i, long l) &#123; Toast.makeText(MainActivity.this,"点击了第"+i+"个itme",Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; private void initData()&#123; if (mContactItem.size() ==0)&#123; for( int i = 0;i &lt; 12; i++)&#123; ContactItem item = new ContactItem(); item.setTitle("我是标题" + i); item.setContext("我是内容" + i); mContactItem.add(item); &#125; &#125; mCommonAdapter = new CommonAdapter(this,mContactItem,R.layout.list_item); &#125; private class CommonAdapter extends CommonAdapterFinal&lt;ContactItem&gt; &#123; public CommonAdapter(Context context, List&lt;ContactItem&gt; datas, int layoutId) &#123; super(context,datas,layoutId); &#125; @Override public void convert(ViewHolder holder, ContactItem contactItem) &#123; holder.setText(R.id.title,contactItem.getTitle()).setText(R.id.content,contactItem.getContent()) .setImageResource(R.id.icon,R.mipmap.ic_launcher); &#125; &#125;&#125; adapter直接写成内部类就行啦！ listView的常见错误1、子控件抢占点击焦点 我写了item的点击事件、但是由于item里有CheckBox子控件抢占了焦点，点击item没有任何反应，这是需要设置CheckBox属性android:focusable = “false” 或者设置当前最外层控件属性android:descendantFocusability=”blocksDescendants”不让焦点往下传，两种方法。 源码 荆轲刺秦王 拜了个拜]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Content Provider]]></title>
      <url>%2F2016%2F10%2F01%2FContent%20Provider%2F</url>
      <content type="text"><![CDATA[ContentProvider基本概念 ContentProvider提供为存储和获取数据提供了统一的接口 使用ContentProvider可以再不同的应用程序之间共享数据 Adroid为常见的一些数据提供了ContentPrivider（包括音频，视频，图片和通讯录等等） 数据模型ContentProvider使用表的形式来组织数据 _ID NUMBER NUBER_KYE LABEL NAME TYPE 12 (425)5556677 4255556677 Kirkland office Bully Pulpit TYPE_WORK 44 (212)555-1234 2125551234 NY apartment Vlan Vain TYPE_HOME 45 (425)5556677 4255556677 Kirkland office Bully Pulpit TYPE_WORK URIURI：统一资源标识符 每一个ContentProvider都有一个公共的URI，这个URI用于表示这个ContentProvider所提供的的数据。 Android所提供的的ContentProvider都存放在Android.provider包当中。 ContentProvider所提供的的函数 query();查询 insert();插入 update():更新 delete();删除 getType();得到数据类型 onCtreat();创建时的回调函数 实现ContentProvider的过程ContentProvider实现访问数据不同的接口，是在不同的应用之间共享数据时所用 定义一个CONTENT_URI常量 定义一个类，继承ContentProvider 实现query，insert，update，delete，getType和onCreate方法 在AndroidManifest.xml当中声明]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 广播机制]]></title>
      <url>%2F2016%2F09%2F25%2Fandroid%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[文章参考) 主要类容Android的广播机制的介绍接受广播时广播（发送方）并不在意我们（接收方）接收到广播时如何处理。好比我们收听交通电台的广播，电台中告诉我们现在在交通状况如何，但它并不关心我们接收到广播时做如何做出处理，这不是广播应该关心的问题，OK，到这里我们从生活中的一些小例子浅浅的理解了一下广播，那么Android 中的广播是如何操作的呢？ 在 Android 里面有各种各样的广播，比如电池的使用状态，电话的接收和短信的接收都会产生一个广播，应用程序开发者也可以监听这些广播并做出程序逻辑的处理。 Android 中有各式各样的广播，各种广播在Android 系统中运行，当系统/应用程序运行时便会向 Android 注册各种广播，Android 接收到广播会便会判断哪种广播需要哪种事件，然后向不同需要事件的应用程序注册事件，不同的广播可能处理不同的事件也可能处理相同的广播事件，这时就需要Android 系统为我们做筛选。 广播被分为两种不同的类型：“普通广播（Normal broadcasts）”和“有序广播（Ordered broadcasts）”。普通广播是完全异步的，可以在同一时刻（逻辑上）被所有接收者接收到，消息传递的效率比较高，但缺点是：接收者不能将处理结果传递给下一个接收者，并且无法终止广播Intent的传播 然而有序广播是按照接收者声明的优先级别（声明在intent-filter元素的android:priority属性中，数越大优先级别越高,取值范围:-1000到1000。也可以调用IntentFilter对象的setPriority()进行设置），被接收者依次接收广播。如：A的级别高于B,B的级别高于C,那么，广播先传给A，再传给B，最后传给C。A得到广播后，可以往广播里存入数据，当广播传给B时,B可以从广播中得到A存入的数据。 Context.sendBroadcast()发送的是普通广播，所有订阅者都有机会获得并进行处理。 Context.sendOrderedBroadcast()发送的是有序广播，系统会根据接收者声明的优先级别按顺序逐个执行接收者，前面的接收者有权终止广播(BroadcastReceiver.abortBroadcast())，如果广播被前面的接收者终止，后面的接收者就再也无法获取到广播。对于有序广播，前面的接收者可以将处理结果通过setResultExtras(Bundle)方法存放进结果对象，然后传给下一个接收者，通过代码：Bundle bundle =getResultExtras(true))可以获取上一个接收者存入在结果对象中的数据。 系统收到短信，发出的广播属于有序广播。如果想阻止用户收到短信，可以通过设置优先级，让你们自定义的接收者先获取到广播，然后终止广播，这样用户就接收不到短信了。 案列一个经典的电话黑名单，首先通过将黑名单号码保存在数据库里面，当来电时，我们接收到来电广播并将黑名单号码与数据库中的某个数据做匹配，如果匹配的话则做出相应的处理，比如挂掉电话、比如静音等等。。。 Demo 分析：下面通过一个小DEMO 来讲解一下广播在Android 中如何编写，在Demo中我们设置了一个按钮为按钮设置点击监听通过点击发送广播，在后台中接收到广播并打印LOG信息。代码如下： 1234567891011121314151617181920public class BroadCastActivity extends Activity &#123; /** Called when the activity is first created. */ public static final String ACTION_INTENT_TEST = "com.terry.broadcast.test"; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); Button btn = (Button) findViewById(R.id.Button01); btn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; // TODO Auto-generated method stub Intent intent = new Intent(ACTION_INTENT_TEST); sendBroadcast(intent); &#125; &#125;); &#125; &#125; 接收器代码如下： 1234567891011public class MyBroadCast extends BroadcastReceiver &#123; public MyBroadCast() &#123; Log.v("BROADCAST_TAG", "myBroadCast"); &#125; @Override public void onReceive(Context context, Intent intent) &#123; Log.v("BROADCAST_TAG", "onReceive"); &#125; &#125; Android 广播的生命周期在上面的接收器中，继承了BroadcastReceiver 并重写了它的onReceive 并构造了一个函数，下面通过图片来一步一步认识 Android 广播的生命周期。当我点击一下按钮，它向Android 发送了一个广播，如下图： 下面画一张图像，描述Android 中广播的生命周期，其次它并不像Activity 一样复杂，运行原理很简单如下图： 下面来看一下SDK给出的解释大意为： 如果一个广播处理完onReceive 那么系统将认定此对象将不再是一个活动的对象，也就会finished掉它。 至此，大家应该能明白 Android 的广播生命周期的原理，代码也不用多介绍，很简单的一个发送广播并处理广播的Demo。 Android 如何判断并筛选广播?前面说过 Android 的广播有各式各样，那么Android 系统是如何帮我们处理我们需要哪种广播并为我们提供相应的广播服务呢？这里有一点需要大家注意，每实现一个广播接收类必须在我们应用程序中的 manifest 中显式的注明哪一个类需要广播，并为其设置过滤器，如下图 Tip:action 代表一个要执行的动作，在Andriod 中有很action 比如 ACTION_VIEW,ACTION_EDIT 那么有些人会问了，如果我在一个广播接收器中要处理多个动作呢？那要如何去处理？ 在Android 的接收器中onReceive 以经为我们想到的，同样的你必须在Intent-filter 里面注册该动作，可以是系统的广播动作也可以是自己需要的广播，之后你之需要在onReceive 方法中，通过intent.getAction()判断传进来的动作即可做出不同的处理，不同的动作。具体大家可以去尝试测试一下。 小结 在Android 中如果要发送一个广播必须使用sendBroadCast 向系统发送对其感兴趣的广播接收器中 使用广播必须要有一个intent 对象必设置其action动作对象 使用广播必须在配置文件中显式的指明该广播对象 每次接收广播都会重新生成一个接收广播的对象 在BroadCast 中尽量不要处理太多逻辑问题，建议复杂的逻辑交给Activity 或者 Service 去处理 如果在AndroidManifest.xml中注册，当应用程序关闭的时候，也会接收到广播。在应用程序中注册就不产生这种情况了。 下面自己来看一下如何在应用程序中注册BroadcastReceiver 利用代码注册 BroadcastReceiver 时有以下步骤： 生成一个 BroadcastReceiver 对象； 生成一个 IntentFilter 对象； 为 IntentFilter 对象添加一个 Action ； 利用 IntentFilter 和 BroadcastReceiver 绑定注册一个 BroadcastReceiver 到系统中，当系统广播该Action事件的时候，就出发该BroadcastReceiver。 应用程序代码： 123456789101112131415161718192021public class SMSReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; System.out.println("receive message"); // 对接受的短消息进行处理 // 接受 Intent 对象中的数据 Bundle bundle = intent.getExtras(); // 在 Bundle 对象当中有一个属性名为 pdus , 这个属性的值是一个 Object数组 Object[] myObjects = (Object[]) bundle.get("pdus"); // 创建一个 SmsMessage 类型的数组 SmsMessage[] message = new SmsMessage[myObjects.length]; System.out.println(message.length); for (int i = 0; i &lt; myObjects.length; i++) &#123; // 使用 Object 数组当中的对象创建 SmsMessage 对象 message[i] = SmsMessage.createFromPdu((byte[]) myObjects[i]); System.out.println(message[i].getDisplayMessageBody()); &#125; &#125; &#125; 12345678public class SMSReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; System.out.println("receive message......"); &#125; &#125; 注意：当如果要进行的操作需要花费比较长的时间，则不适合放在BroadcastReceiver中进行处理，引用网上找到的一段解释： “在 Android 中，程序的响应（ Responsive ）被活动管理器（ Activity Manager ）和窗口管理器（ Window Manager ）这两个系统服务所监视。当 BroadcastReceiver 在 10 秒内没有执行完毕，Android 会认为该程序无响应。所以在 BroadcastReceiver 里不能做一些比较耗时的操作，否侧会弹出ANR （ Application No Response ）的对话框。如果需要完成一项比较耗时的工作，应该通过发送Intent 给 Service ，由 Service 来完成。而不是使用子线程的方法来解决，因为 BroadcastReceiver 的生命周期很短（在 onReceive() 执行后 BroadcastReceiver 的实例就会被销毁），子线程可能还没有结束BroadcastReceiver 就先结束了。如果 BroadcastReceiver 结束了，它的宿主进程还在运行，那么子线程还会继续执行。但宿主进程此时很容易在系统需要内存时被优先杀死，因为它属于空进程（没有任何活动组件的进程）。 如果要进行的操作占用时间比较长，最好能调用新的Activity或Service进行处理，在调用Intent调用新的 Activity或Service时，其代码如下： 12345678Intent myIntent = new Intent(); //通过Intent对象把信息的内容和发送人的号码发给新的Activity myIntent.putExtra("SMSBody", strSMSBody); myIntent.putExtra("SMSAdress", strSMSAdress); //从Service或BroadcastReciver往Activity跳转时，要将Intent的Flag设置为FLAG_ACTIVITY_NEW_TASK才可以 myIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); myIntent.setClass(context, BroadcastActivity.class); context.startActivity(myIntent); 这里再添加一点： 在注册广播接收器的时候，静态注册往往比动态注册的优先级别要高。所以要想注册一个电话拦截在最前面，可以在注册一个系统启动广播，当系统启动的时候，系统会发送一个启动广播，然后在广播里注册你所需要的广播接收器；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android XML文件解析]]></title>
      <url>%2F2016%2F09%2F20%2FAndroid%20XML%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[主要内容什么是SAX SAX，全称Simple API for XML,既是一种接口，也指一个软件包 作为接口，SAX 是事件驱动型XML的唯一标准接口 优点:逐行的扫描文档，一边扫描一边解析，可以在解析文档的任意时刻停止解析；缺点是操作比较复杂，不能对文档进行修改 SAX的基本原理SAX的工作原理简单的说就是对文档进行顺序扫描，当扫描到文档（document）开始与结束，元素（element）开始与结束，文档（document）开始与结束等地方时通知时间处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。 大多数SAX事项都会产生一项类型的事件： 在文档的开始和结束时出发文档处理事件。 在文档内每一XML元素接受解析的前后触发元素事件。 在任何元素据通常都由单独的事件交付。 在处理文档的DTD或Schema时产生DTD或Schema事件。 产生错误事件用来通知主机应用程序解析错误。 SAX模型 解析文档的过程123&lt;doc&gt; &lt;para&gt;Hello,world!&lt;/para&gt;&lt;/doc&gt; 在解析过程中会产生如下一系列事件; start document start element:doc start element:para characters:Hello,world! end element:para end element:doc end document 创建事件处理程序—&gt;创建SAX解析器—-&gt;将事件处理程序(接口的实现类)分配个解析器—-&gt;对文档进行解析，将每个事件发送给处理程序 SAX的常用接口ContentHandler接口ContentHandler接口是Java类包中一个特殊的SAX接口，位于org.xml.sax包中。该接口封装了一些对事件的处理的方法，当XML解析器开始解析XML输入文档时，它会遇到某些特殊的时间，比如文档的开头和结束、元素的开头和结束、以及元素中的字符数据等事件。当遇到这些事件时，XML解析器会调用ContentHandler接口中相应的方法来响应该事件。 ContentHandler接口的方法有以下几种： void startDocument() void endDocument() void StartElement(String uri,String localName,String qName,Attributes atts) void endElement(String uri,String localName,String qName) void characters(char[] ch,int start,int length) SAX解析创建一个SAXParserFactory 12SAXParserFactory factory = SAXParserFactory.newInstance();XMLReder reader = factory.newSAXParser().getXMLReader(); 为XMLReader设置内容处理 1reader.setContentHandler(new MyContentHander()); 开始解析文件 1reader.parse(new InputSource(new StringReader(resultStr)));]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用android DwonLoad文件]]></title>
      <url>%2F2016%2F09%2F18%2Fandroiddownload%2F</url>
      <content type="text"><![CDATA[使用android下载文件 下载方法HttpDownloader1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class HttpDownloader&#123; private URL url; /* * 根据URL下载文件，前提是这个文件当中的内容是文本，函数的返回值就是文件当中的内容 * 1.创建一个URL对象 * 2.通过URL对象，创建一个HttpURLConnection对象 * 3.得到InputStream * 4.从InputStream当中读取数据 * */ //uelStr 链接地址 download方法返回一个文本对象 public String download(String urlStr)&#123; StringBuffer sb = new StringBuffer(); String line; BufferedReader buffer =null; InputStream inputStream; try&#123; //创建一个URL对象 传入参数为下载地址 url = new URL(urlStr); inputStream = getInputstreamFromUrl(urlStr); //创建一个Http链接 向下转型 /* HttpURLConnection urlconn = (HttpURLConnection) url.openConnection(); //使用IO流读取数据 装饰者设计模式 // 转换为安行读取 &lt;---- 转换为安字符读取 &lt;--- 读取字节 buffer = new BufferedReader(new InputStreamReader(urlconn.getInputStream()));*/ buffer = new BufferedReader(new InputStreamReader(inputStream)); while((line = buffer.readLine()) != null)&#123; sb.append(line); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; try&#123; buffer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return sb.toString(); &#125; public int downFile(String urlStr,String path,String fileName)&#123; InputStream inputStream = null; try&#123; FileUtils fileUtils = new FileUtils(); if (fileUtils.isFileExist(path + fileName))&#123; return 1; &#125;else &#123; inputStream = getInputstreamFromUrl(urlStr); File resultFile = fileUtils.write2SDFromInput(path,fileName,inputStream); if(resultFile == null)&#123; return -1; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return 0; &#125; /* * 根据URL得到输入流 * @param urlStr * @return * @throws MalformedURLException * @throws IOException * */ public InputStream getInputstreamFromUrl(String urlStr) throws IOException &#123; url = new URL(urlStr); HttpURLConnection urlConn = (HttpURLConnection) url.openConnection(); InputStream inputStream = urlConn.getInputStream(); return inputStream; &#125;&#125; 写入SD卡 FileUtils123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class FileUtils &#123; private String SDPATH; public String getSDPATH()&#123; return SDPATH; &#125; public FileUtils()&#123; //得到当前设备的目录 SDPATH = Environment.getExternalStorageDirectory() + ""; &#125; /* *在SD卡上创建文件 * @throws IOException * */ public File creatSDFile(String fileName) throws IOException &#123; File file = new File(SDPATH +fileName); file.createNewFile(); return file; &#125; /* * 在SD卡上创建目录 * */ public File creatSDDir(String dirName)&#123; File dir =new File(SDPATH + dirName); dir.mkdir(); return dir; &#125; /* * 判断SD卡上的文件夹是否存在 * */ public boolean isFileExist(String fileName)&#123; File file = new File(SDPATH + fileName); return file.exists(); &#125; /* * 将一个InputStream里面的数据写入到SD卡中 * path 写入哪一个目录 * 目录下的fileName文件名 * input 向文件里写入数据 * */ public File write2SDFromInput(String path, String fileName, InputStream input)&#123; File file = null; OutputStream output = null; try&#123; creatSDDir(path); file = creatSDFile(path + fileName); output =new FileOutputStream(file); byte buffer [] = new byte[4 * 1024]; while((input.read(buffer) != -1))&#123; output.flush(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; try &#123; output.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return file; &#125;&#125; 下载实现Download1234567891011121314151617181920212223242526272829303132public class Download extends AppCompatActivity &#123; private Button downloadTxtButton; private Button downloadMp3Btton; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_download); downloadTxtButton = (Button) findViewById(R.id.downloadTxtButton); downloadMp3Btton = (Button) findViewById(R.id.downloadMp3Button); downloadMp3Btton.setText(R.string.downloadMp3); downloadTxtButton.setText(R.string.downloadTxt); downloadTxtButton.setOnClickListener(new DownloadTxtListener()); downloadMp3Btton.setOnClickListener(new DownloadMp3Lisener()); &#125; class DownloadTxtListener implements View.OnClickListener&#123; @Override public void onClick(View view) &#123; HttpDownloader httpDownloader = new HttpDownloader(); String lrc =httpDownloader.download("http://www.cnlyric.com/LrcDown/3037/109693.lrc"); System.out.println(lrc); &#125; &#125; class DownloadMp3Lisener implements View.OnClickListener&#123; @Override public void onClick(View view) &#123; HttpDownloader httpDownloader = new HttpDownloader(); int result = httpDownloader.downFile("http://ok.96x.cn/2015/7yue_2651.cn/%E6%83%85%E9%9D%9E%E5%BE%97%E5%B7%B2%20-%20%E5%BA%BE%E6%BE%84%E5%BA%86.mp3","telyo","1"); System.out.println(result); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello gitHub&hexo!]]></title>
      <url>%2F2016%2F09%2F16%2Ftest%2F</url>
      <content type="text"><![CDATA[终于有了自己的博客了，没白费我这几天的一番苦心，好好加油吧！！……………………………………………………………….]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[测试Cmd Markdown 编辑阅读器]]></title>
      <url>%2F2016%2F09%2F11%2Fhello%2F</url>
      <content type="text"><![CDATA[欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 高效绘制 甘特图12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 7. 绘制表格 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 8. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2016 年 07月 07日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。]]></content>
    </entry>

    
  
  
</search>
